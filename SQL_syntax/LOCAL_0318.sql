INSERT INTO store_information (STORE_ID, STORE_NAME, SALES, STORE_DATE, GEOGRAPHY_ID)
	VALUES(10, 'AppleInc', 1000, '2023-03-11 00:00:00', 3);
    
SELECT * FROM store_information;

-- 可對交易異動中的資料在資料未提交commit前，進行rollback取消這次交易所有的資料異動指令
ROLLBACK;

-- COMMIT 完成交易作業
-- 如進行資料異動操作後最後須執行交易提交commit的動作資料方可異動成功
-- 交易隔離性：資料庫交易與交易之間彼此獨立，一個交易是看不到另一個交易所異動中的資料
COMMIT;


-- SQL UNION 聯集(不包含重覆值)
-- 1.查詢與查詢之間SELECT的欄位"個數必須相同"
-- 2.查詢與查詢之間SELECT的欄位"型別相同"
-- 1,2,3
SELECT GEOGRAPHY_ID  FROM GEOGRAPHY
UNION
-- NULL,1,2,3
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION;

-- SQL UNION ALL 聯集(包含重覆值)
-- 1,2,3
SELECT GEOGRAPHY_ID  FROM GEOGRAPHY
UNION ALL
-- NULL,1,2,3
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION;

-- SQL INTERSECT 交集
-- MySQL不支援INTERSECT語句
/*
SELECT GEOGRAPHY_ID  FROM GEOGRAPHY
INTERSECT
-- NULL,1,2,3
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION;
*/

-- INNER JOIN + DISTINCT = INTERSECT 查詢交集結果
SELECT DISTINCT G.GEOGRAPHY_ID
FROM GEOGRAPHY G
JOIN STORE_INFORMATION S ON G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;

-- SQL MINUS 排除(不包含重覆值) 
-- MySQL不支援MINUS語句
/*
-- Oracle
SELECT GEOGRAPHY_ID  FROM GEOGRAPHY
MINUS
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION;

-- MS SQL
SELECT GEOGRAPHY_ID  FROM GEOGRAPHY
EXCEPT
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION;
*/

-- LEFT JOIN + table2.id IS NULL = MINUS
SELECT G.GEOGRAPHY_ID
FROM GEOGRAPHY G
LEFT JOIN STORE_INFORMATION S ON G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
WHERE S.GEOGRAPHY_ID IS NULL;

-- SQL SubQuery 子查詢

-- 找出營業額最高的商店資料
-- 外查詢
SELECT * 
FROM STORE_INFORMATION
WHERE SALES = (
	-- 內查詢
	SELECT MAX(SALES) FROM STORE_INFORMATION
);

-- 內部查詢本身與外部查詢沒有關係。
-- 這一類的子查詢稱為『簡單子查詢』 (Simple Subquery)
SELECT SUM(SALES)
FROM STORE_INFORMATION
WHERE GEOGRAPHY_ID IN (
	-- 1,2,3
	SELECT GEOGRAPHY_ID FROM GEOGRAPHY
);

-- 內部查詢是要利用到外部查詢提到的表格中的欄位，
-- 那這個字查詢就被稱為『相關子查詢』(Correlated Subquery)
-- 外查詢
SELECT SUM(SALES)
FROM STORE_INFORMATION S
WHERE S.GEOGRAPHY_ID IN (
	-- 內查詢
	SELECT G.GEOGRAPHY_ID FROM GEOGRAPHY G
    WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
);


-- 『簡單子查詢』 (Simple Subquery)
-- 每個子查詢都可視為一個資料查詢的結果集
-- 查詢與查詢之間"彼此獨立"不能互相使用對方的欄位
SELECT G.*, S.*
FROM (
   SELECT * FROM GEOGRAPHY
) G , 
(
   SELECT * FROM STORE_INFORMATION
) S
WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;


SELECT G.*, S.*
FROM (
   SELECT * FROM GEOGRAPHY
) G , 
(
   SELECT STORE.* 
   FROM STORE_INFORMATION STORE, G
   WHERE STORE.GEOGRAPHY_ID = G.GEOGRAPHY_ID
) S
WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;



-- 『相關子查詢』(Correlated Subquery)
WITH G AS (
	SELECT * FROM GEOGRAPHY
),
S AS (
	SELECT * FROM STORE_INFORMATION
)
SELECT G.*, S.* 
FROM G 
JOIN S ON G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;


WITH G AS (
	SELECT * FROM GEOGRAPHY
),
S AS (
	SELECT STORE.* 
    FROM STORE_INFORMATION STORE, G
    WHERE STORE.GEOGRAPHY_ID = G.GEOGRAPHY_ID
)
SELECT S.* FROM S;

-- SQL EXISTS 存在式關聯查詢
-- EXISTS 是用來測試「內查詢」有沒有產生任何結果。
-- 如果有的話，系統就會執行「外查詢」中的 SQL。
-- 若是沒有的話，那整個 SQL 語句就不會產生任何結果。

-- 外查詢
SELECT * FROM STORE_INFORMATION
WHERE EXISTS (
	-- 內查詢
	SELECT * FROM GEOGRAPHY G
    WHERE G.GEOGRAPHY_ID = 1
);

-- 外查詢
SELECT * FROM STORE_INFORMATION
WHERE NOT EXISTS (
	-- 內查詢
	SELECT * FROM GEOGRAPHY G
    WHERE G.GEOGRAPHY_ID = 1
);

-- 存在關聯子查詢
-- 外查詢
SELECT * FROM STORE_INFORMATION S
WHERE EXISTS (
	-- 內查詢
	SELECT * FROM GEOGRAPHY G
    WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
    AND G.GEOGRAPHY_ID = 1
);


-- SQL CASE WHEN 條件查詢
-- 1.CASE後接欄位名
SELECT STORE_ID, STORE_NAME, SALES,
	CASE STORE_NAME
		WHEN 'Los Angeles' THEN SALES * 2
        WHEN 'San Diego' THEN SALES * 1.5
        ELSE SALES
     END "NEW_SALES"
FROM STORE_INFORMATION
ORDER BY STORE_NAME;

-- 2.CASE後不接欄位名(只有WHEN條件)
SELECT STORE_ID, STORE_NAME, SALES,
	CASE
		WHEN (SALES BETWEEN 0 AND 1000) THEN '0-1000'
        WHEN (SALES BETWEEN 1001 AND 2000) THEN '1001- 2000'
        WHEN (SALES BETWEEN 2001 AND 3000) THEN '2001- 3000'
        WHEN SALES > 3000 THEN '>3000'
     END "RANGE_SALES"
FROM STORE_INFORMATION
ORDER BY SALES;

-- Rank(排名函數) 
SELECT STORE_ID, STORE_NAME, SALES,
	RANK()OVER(ORDER BY SALES DESC) "STORE_RANK"
FROM STORE_INFORMATION;

-- Rank(分群排名函數)
-- 各別商店做分群營業額排名
SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID,
	RANK()OVER(PARTITION BY GEOGRAPHY_ID ORDER BY SALES DESC) "GEOGRAPHY_STORE_RANK"
FROM STORE_INFORMATION;

-- Analytic Functions with OVER Clause (分析函數)
-- DENSE_RANK (  )：當有同名次時(排名结果是連續的)
-- PERCENT_RANK (  )：名次所佔的百分比 (值會介於 0 ~ 1 之間)
-- 公式：(RANK(  ) - 1)  /  (總資料列筆數 - 1)
-- ROW_NUMBER (  ) ：依序編號
SELECT STORE_ID, STORE_NAME, SALES,
	RANK()OVER(ORDER BY SALES DESC) "STORE_RANK",
    DENSE_RANK()OVER(ORDER BY SALES DESC) "STORE_DENSE_RANK",
    PERCENT_RANK()OVER(ORDER BY SALES DESC) "STORE_PERCENT_RANK",
    ROW_NUMBER()OVER(ORDER BY SALES DESC) "STORE_ROW_NUMBER"
FROM STORE_INFORMATION;

-- Aggregate Functions with OVER clause (聚合函數)
SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID,
    -- 依「區域劃分」取營業額"最小值"
    MIN(SALES) OVER (PARTITION BY GEOGRAPHY_ID) MIN_SALES,
    -- 依「區域劃分」取營業額"最大值"
    MAX(SALES) OVER (PARTITION BY GEOGRAPHY_ID) MAX_SALES,
    -- 依「區域劃分」取商店"數量"
    COUNT(STORE_ID) OVER (PARTITION BY GEOGRAPHY_ID) COUNT_STORE_ID,
    -- 依「區域劃分」取營業額"總和"
    SUM(SALES) OVER (PARTITION BY GEOGRAPHY_ID) SUM_SALES,
    -- 依「區域劃分」取營業額"平均"
    AVG(SALES) OVER (PARTITION BY GEOGRAPHY_ID) AVG_SALES,
	ROUND(AVG(SALES) OVER (PARTITION BY GEOGRAPHY_ID), 1) ROUND_AVG_SALES
FROM STORE_INFORMATION
ORDER BY GEOGRAPHY_ID, SALES;


SELECT * FROM STORE_INFORMATION;

-- Analytic Functions with OVER clause(分析函數)
SELECT STORE_ID, STORE_NAME,
    ROW_NUMBER( ) OVER (ORDER BY SALES) ROWNO_STORE,
    SALES,
    -- 依「營業額」排序取"上一個"營業額
    LAG(SALES) OVER (ORDER BY SALES) PREV_SALES,
    -- 依「營業額」排序取"下一個"營業額
    LEAD(SALES) OVER (ORDER BY SALES) NEXT_SALES
FROM STORE_INFORMATION
ORDER BY SALES;


-- CEIL(x)：返回大於或等於x的最大整數值(無條件進位)
-- FLOOR(x)：返回小於或等於x的最小整數值(無條件捨去)
-- ROUND(x ,y)：
-- 返回(四捨五入)到小數點右邊y位的x值,y預設值為0
-- 如果y是負數，則捨入到小數點左邊相應的整數位上

SELECT CEIL(123.4), FLOOR(123.9), 
	ROUND(123.5), ROUND(1234.56, 1), ROUND(1234.54, 1),
    ROUND(1234, -2), ROUND(1254, -2);
    
    
-- MySQL轉換函數：
-- 1.DATE_FORMAT(date,format):日期轉字串
SELECT SYSDATE();
SELECT DATE_FORMAT(SYSDATE(), '%m-%d-%Y %T'),
-- 2.STR_TO_DATE(str,format):字串轉日期
STR_TO_DATE('2021-08-15 00:00:00', "%Y-%m-%d %T"),
DATE_ADD(STR_TO_DATE('2021-08-15 00:00:00', "%Y-%m-%d %T"), INTERVAL 5 DAY);

-- Oracle 轉換函數：
-- 1.TO_CHAR(d , format)：日期轉字串
/*
SELECT TO_CHAR(SYSDATE,'YYYY-mm-DD HH24:MI:SS'),
  -- 2.TO_DATE(string ,format)：字串轉日期
  TO_DATE('2018-05-15 12:30:23','YYYY-mm-DD HH24:MI:SS'),
  -- 3.TO_TIMESTAMP(string,  [format])：字串轉日期
  TO_TIMESTAMP( '2011-12-23 12:30:23.852', 'YYYY-MM-DD HH24:MI:SS.FF3')
FROM DUAL;
*/

-- MS SQL
-- 1.日期轉字串
/*
SELECT convert(varchar, getdate(), 100) 'mon dd yyyy hh:mmAM (or PM)';
SELECT convert(varchar, getdate(), 101) 'mm/dd/yyyy';
SELECT convert(varchar, getdate(), 102) 'yyyy.mm.dd';
SELECT convert(varchar, getdate(), 103) 'dd/mm/yyyy';
SELECT convert(varchar, getdate(), 104) 'dd.mm.yyyy';
SELECT convert(varchar, getdate(), 105) 'dd-mm-yyyy';
SELECT convert(varchar, getdate(), 106) 'dd mon yyyy';
SELECT convert(varchar, getdate(), 107) 'mon dd, yyyy';
SELECT convert(varchar, getdate(), 108) 'hh:mm:ss';
SELECT convert(varchar, getdate(), 109) 'mon dd yyyy hh:mm:ss:mmmAM (or PM)';
SELECT convert(varchar, getdate(), 110) 'mm-dd-yyyy';
SELECT convert(varchar, getdate(), 111) 'yyyy/mm/dd';
SELECT convert(varchar, getdate(), 112) 'yyyymmdd';
SELECT convert(varchar, getdate(), 113) 'dd mon yyyy hh:mm:ss:mmm';
SELECT convert(varchar, getdate(), 114) 'hh:mm:ss:mmm(24h)';
SELECT convert(varchar, getdate(), 120) 'yyyy-mm-dd hh:mm:ss(24h)';
SELECT convert(varchar, getdate(), 121) 'yyyy-mm-dd hh:mm:ss.mmm';
SELECT convert(varchar, getdate(), 126) 'yyyy-mm-ddThh:mm:ss.mmm';

-- 2.字串轉日期
SELECT convert(datetime, '2021-08-16 21:52:22', 120)　'yyyy-mm-dd hh:mm:ss(24h)';
*/

-- MySQL
SELECT SYSDATE(), YEAR(SYSDATE()), MONTH(SYSDATE()), DAY(SYSDATE()),
HOUR(SYSDATE()), MINUTE(SYSDATE()), SECOND(SYSDATE());

SELECT STORE_ID, STORE_NAME, STORE_DATE
FROM STORE_INFORMATION
WHERE YEAR(STORE_DATE) = 2018 
AND MONTH(STORE_DATE) BETWEEN 1 AND 3;


-- oracle
-- TRUNC(date, [format])：對日期作無條件捨去運算
-- MONTH(月捨去)、YEAR(年捨去)、不帶FORMAT(日捨去)
/*
SELECT SYSDATE, TRUNC(SYSDATE), TRUNC(SYSDATE, 'MONTH'), TRUNC(SYSDATE, 'YEAR')
FROM DUAL;
*/

-- MS SQL
/*
SELECT GETDATE(), YEAR(GETDATE()), MONTH(GETDATE()), DAY(GETDATE());

SELECT GETDATE() 'Today',
DATEPART(year,GETDATE()) 'Year Part',
DATEPART(month,GETDATE()) 'Month Part',
DATEPART(day,GETDATE()) 'Day Part',
DATEPART(hour,GETDATE()) 'Hour Part',
DATEPART(minute,GETDATE()) 'Minute Part',
DATEPART(second,GETDATE()) 'Second Part',
DATEPART(millisecond,GETDATE()) 'MilliSecond Part';
*/

--  MySQL日期算術:
SELECT SYSDATE(), 
DATE_ADD(SYSDATE(), INTERVAL 1 DAY),
DATE_ADD(SYSDATE(), INTERVAL 1 MINUTE),
DATE_ADD(SYSDATE(), INTERVAL -1 DAY),
DATE_ADD(SYSDATE(), INTERVAL -1 MINUTE);

-- Oracle INTERVAL 日期計算
/*
SELECT SYSDATE,
SYSDATE - INTERVAL '1' YEAR,
SYSDATE + INTERVAL '1' YEAR,
SYSDATE - INTERVAL '1' MONTH,
SYSDATE - INTERVAL '1' DAY,
SYSDATE - INTERVAL '1' HOUR,
SYSDATE - INTERVAL '1' MINUTE,
SYSDATE - INTERVAL '1' SECOND
FROM DUAL;
*/

-- MS SQL
/*
SELECT GETDATE(),
DATEADD(YEAR, 1, GETDATE()) "DATEADD_YEAR",
DATEADD(MONTH, 1, GETDATE()) "DATEADD_MONTH",
DATEADD(DAY, 1, GETDATE()) "DATEADD_DAY",
DATEADD(HOUR, 1, GETDATE()) "DATEADD_HOUR",
DATEADD(MINUTE, 1, GETDATE()) "DATEADD_MINUTE",
DATEADD(SECOND, 1, GETDATE()) "DATEADD_SECOND";

SELECT GETDATE(),
DATEADD(YEAR, -1, GETDATE()) "DATESUB_YEAR";
*/

